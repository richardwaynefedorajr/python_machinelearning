## File name: detectCircles.py
## Project specifics: (package, workspace, etc.) - ECE 5554 Computer Vision PS2
## Author: Richard Wayne Fedora Jr. 
## Email: rfedora1@vt.edu
## Phone: (706) 254-8887
## Date of most recent edit: Monday, October 5, 20.7
## 
## Code synopsis: this file contains a python function which implements the Hough Transform Circle detector
## I/O: 
## im - the image to be processed
## radius - specifies size of circle to be detected
## useGradient - option to exploit gradient direction measured at edge points
## centers - output matrix of [x,y] positions of detected circle centers

import numpy as np
from numpy import ndarray
from scipy import misc
from skimage import feature
from skimage import color
from skimage import draw
import matplotlib.pyplot as plt
import math

def applyHoughGradient(H, gradient, edge_pixel, radius, i):
    x_grad = gradient[0][edge_pixel[0][i],edge_pixel[1][i]]
    y_grad = gradient[1][edge_pixel[0][i],edge_pixel[1][i]]
    if (x_grad != 0):
        angle = [np.rad2deg(np.arctan(y_grad/x_grad)), -np.rad2deg(np.arctan(y_grad/x_grad))]
    else:
        angle = []
    for k in range(len(angle)):
        a = edge_pixel[0][k] - radius*np.cos(angle[k])
        b = edge_pixel[1][k] + radius*np.sin(angle[k])
        if (round(a) < H.shape[0] and round(b) < H.shape[1]):
            H[round(a),round(b), 0 if H.shape[2] == 1 else radius] += 1
    return

def applyHough(H, edge_pixel, i, radius, angle):
    a = edge_pixel[0][i] - radius*np.cos(angle)
    b = edge_pixel[1][i] + radius*np.sin(angle)
    if (round(a) < H.shape[0] and round(b) < H.shape[1]):
        H[round(a),round(b), 0 if H.shape[2] == 1 else radius] += 1

def updateImage(H, im, radius):
    if (np.where(H > 0.7*np.max(H))[0].size == 1):
        [rr,cc] = draw.circle_perimeter(np.where(H > 0.7*np.max(H))[0], np.where(H > 0.7*np.max(H))[1], np.where(H > 0.7*np.max(H))[2])
        if np.max(rr) < len(H[:,0]) and np.max(cc) < len(H[0,:]):
            im[rr,cc,0] = 255
            im[rr,cc,1] = im[rr,cc,2] = 0
    else:
        for i in range(len(np.where(H > 0.7*np.max(H))[0])):
            [rr,cc] = draw.circle_perimeter(np.where(H > 0.7*np.max(H))[0][i], np.where(H > 0.7*np.max(H))[1][i], np.where(H > 0.7*np.max(H))[2][i])
            if np.max(rr) < len(H[:,0]) and np.max(cc) < len(H[0,:]):
                im[rr,cc,0] = 255
                im[rr,cc,1] = im[rr,cc,2] = 0

def detectCircles(im, radius_in, useGradient):
    gray = color.rgb2gray(im)
    edge_pixel = np.where(feature.canny(gray, 1.5) == 1)

    imgplot = plt.imshow(feature.canny(gray, 1.5))
    plt.show()
 
    if radius_in != 0:
        H = np.zeros([gray.shape[0], gray.shape[1], 1])
        radius = np.array([radius_in])
    else:
        H = np.zeros([gray.shape[0], gray.shape[1], round(0.05*len(gray[0,:]))])
        radius = np.arange(0,len(H[0,0,:]))

    for i in range(len(edge_pixel[0])):
        for r in radius:
            if useGradient:
                applyHoughGradient(H, np.gradient(gray), edge_pixel, r, i)
            else:
                for angle in range(0,360,1):
                    applyHough(H, edge_pixel, i, r, angle)

    updateImage(H, im, radius)
    for i in range(len(H[0,0,:])):
        imgplot = plt.imshow(H[:,:,i])
        plt.show()
  
    imgplot = plt.imshow(im)
    plt.show()

    return 112
